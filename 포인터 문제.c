int main()
{

    // 포인터 이해 확인 문제
    // 문제1.
    short sArr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    int *pI = (int *)sArr;

    int iData = *((short *)(pI + 2));

    printf("1번 문제 정답 : %d\n", iData);

    // 문제 2.
    char cArr[2] = {1, 1};

    short *pS = (short *)cArr;

    iData = *pS;

    printf("2번 문제 정답 : %d\n", iData);

    return 0;
}

/*
    1번 정답 : 5
    풀이
    -> short sArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

     int* pI = (int*)sArr;
     // short sArr을 int로 강제 캐스팅하여 4byte로 인지한다.
     int iData = *((short*)(pI + 2));
     // pI는 int 포인터기 때문에 +2를 하면 주소 값 8byte를 가리키며,
     // 그걸 다시 short로 캐스팅하기 때문이다.
     // 1(2바이트) 2(2바이트) 3(2바이트) 4(2바이트) 5(2바이트)

    2번 정답 : 257
    풀이
    ->   char cArr[2] = { 1, 1 };

     short* pS = (short*)cArr;
     // char cArr을 short로 강제 캐스팅하여 2byte로 인지한다.
     iData = *ps;
     // 2바이트로 보기 때문에 0000 0001 / 0000 0001 라는 걸 알 수 있다.

     만약 char cArr[2] = { 2, 1 };
     // 빅엔디안, 리틀 엔디안에 따라서 메모리 읽기 및 저장방식이 다르다.
     // 리틀엔디안 방식에서는 앞쪽 메모리를 하위비트로 시작해서 뒤로 갈 수록
     // 상위 비트로 인지하기 때문에 앞에 배치된 숫자가 하위 비트가 됩니다.
     // 위의 강제 캐스팅으로 인한 문제에서 { 2, 1 }을 할 경우에 258의 값을 얻을 수 있다.
     // 선언한 자료형 단위와 읽는 단위가 정확하게 일치하면 이런 오해의 소지가 없지만,
     // 이미 1바이트 단위로 설정한 값을 2바이트 단위로 읽어 들었기 때문에 발생한 문제다.
     // 따라서 더더욱 선언 단위와 접근 포인터가 일치해야 하는 이유다.
*/